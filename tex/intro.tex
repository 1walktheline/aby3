\section{Introduction}

asdf, bla. Set intersection, union, database operations, composable.




\input{related}


\subsection{Our Results}

We present the first composable



\subsection{Functionality}

Our protocol offers a wide variety of functionality including set intersection, set union, set difference and a variety of SQL-like joins with complex boolean queries. Generally speaking, our protocol works on tables of secret shared data which are functionally similar to SQL tables. This is contrasted by traditional PSI and PSU protocols in that each record is now a tuple as opposed to a single element. 

We define our database tables in the natural way. Each table can be view as a collection of rows or as a vector of columns. For a table $X$, we denote the $i$th row as $X[i]$ and the $j$th column as $X_j$. Note that each column of a table has the same length but can contain different data types, e.g. $X_1$ is a column of 32 bit fixed point decimal values and $X_2$ is a column of 1024 bit strings.

Our core protocol requires that the columns/keys being \emph{joined on} contain unique values. For example, if we consider the SQL styled join/intersection query
$$
\texttt{select } X_1, X_2, Y_2 \texttt{ from } X \texttt{ inner join } Y \texttt{ on } X_1 = Y_1
$$
then the joined on columns are $X_1$ and $Y_1$. This uniqueness condition can also be extended to the setting where multiple columns are being compared for equality. In this case the tuple of these columns must be unique. Later on we will discuss the case when such a uniqueness property does not hold. Our protocols also support a \texttt{where} clause which filters the selection using an arbitrary predicate of the $X$ and $Y$ row. Furthermore, the \texttt{select} clause can also return a function of the two rows. For example,
$$
\texttt{select } X_1,max(X_2, Y_2)  \texttt{ from } X \texttt{ inner join } Y \texttt{ on } X_1 = Y_1 \texttt{ where } Y_2 > 23.3
$$

So far we have discussed inner join (intersection) between two tables. Several other types of joins are also supported including left and right joins, set union and set minus (difference) and full joins. A left join takes the inner join and includes all of the missing records from the left table. For the records solely from the left table, the resulting table contains \texttt{NULL} for the columns from the right table. Right joins are the symmetric operations. A full join is a natural extension of this where all the missing rows from $X$ and $Y$ are added to the output table.

We define the union of two tables to contains all records from the left table along with all the records from the right table which are not in the intersection. We define union in this way due an ambiguity around which table the records in the intersection should come from. Table minus is similarly defined as all of the left table where the joined on column(s) is not present in the right table. 

Beyond these various join operations, our framework supports two broad classes of operations which are a function of a single table. The first is a general SQL select statement which can perform computation on each row (e.g. compute the max of two columns) and filter the results using a \texttt{where} clause predicate. The second class is referred as an aggregation which perform an operation across all of the rows of a table. For example, computing the sum or the max of a given column. 


