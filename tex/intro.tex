\section{Introduction}

asdf, bla. Set intersection, union, database operations, composable.




\input{related}


\subsection{Our Results}

We present the first composable



\subsection{Functionality}

Our protocol offers a wide variety of functionality including set intersection, set union, set difference and a variety of SQL-like joins with complex boolean queries. Generally speaking, our protocol works on tables of secret shared data which are functionally similar to SQL tables. This is contrasted by traditional PSI and PSU protocols in that each record is now a tuple as opposed to a single element. 

We define our database tables in the natural way. Each table can be view as a collection of rows or as a vector of columns. For a table $X$, we denote the $i$th row as $X[i]$ and the $j$th column as $X_j$. Note that each column of a table has the same length but can contain different data types, e.g. $X_1$ is a column of 32 bit fixed point decimal and $X_2$ is a column of 1024 bit string.

Our core protocol requires that the columns being \emph{joined on} contain unique values. For example, if we consider the SQL styled join/intersection query
$$
\texttt{select } X_1, X_2, Y_2 \texttt{ from } X \texttt{ inner join } Y \texttt{ on } X_1 = Y_1
$$
then the joined on columns are $X_1$ and $Y_1$. This uniqueness condition can also be extended to where multiple columns are being compared for equality. In this case the union of the columns must be unique. Later on we will discuss the case when such a uniqueness property does not hold. Our protocols also support a \texttt{where} clause which filters the selection using an arbitrary predicate of the $X$ and $Y$ row. Furthermore, the \texttt{select} clause can also return a function of the two rows. For example,
$$
\texttt{select } X_1,max(X_2, Y_2)  \texttt{ from } X \texttt{ inner join } Y \texttt{ on } X_1 = Y_1 \texttt{ where } Y_2 > 23.3
$$

So far we have discussed inner join (intersection) between two tables. Several other types of joins are also supported including left and right joins, set union and set minus (difference) and full joins. A left join takes the inner join and includes all of the missing records from the left table. For these missing records, the result is \texttt{NULL} if the selected column is from the right table. Right joins are the symmetric operations. A full join is a natural extension of this where all the missing rows from $X$ and $Y$ are added to the output table.

Set union takes two tables each with one or more joined on columns and returns the result table which contains all records from the left table and the records from the right table which are not in the intersection. We define union in this way due to how records which are in the intersection are selected from the left table. Set minus is similarly defined as all of the left table where the joined on column(s) is not present in the right table. 

Beyond these various join operations, our framework supports two broad classes of operations which are a function of a single table. The first is a general SQL select statement which can perform computation on each row (e.g. compute the max of two columns) and filter the results using a \texttt{where} clause predicate. The second class is referred as reduce operations which perform an aggregation across all of the rows of a table. For example, computing the sum or the max of a given column. 


